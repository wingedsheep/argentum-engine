package com.wingedsheep.engine.mechanics.mana

import com.wingedsheep.engine.core.GameEvent
import com.wingedsheep.engine.core.TappedEvent
import com.wingedsheep.engine.core.ZoneChangeEvent
import com.wingedsheep.engine.state.GameState
import com.wingedsheep.engine.state.ZoneKey
import com.wingedsheep.engine.state.components.battlefield.TappedComponent
import com.wingedsheep.engine.state.components.identity.CardComponent
import com.wingedsheep.engine.state.components.identity.ControllerComponent
import com.wingedsheep.sdk.core.Color
import com.wingedsheep.sdk.core.Keyword
import com.wingedsheep.sdk.core.ManaCost
import com.wingedsheep.sdk.core.ManaSymbol
import com.wingedsheep.sdk.core.Zone
import com.wingedsheep.sdk.model.CardDefinition
import com.wingedsheep.sdk.model.EntityId
import com.wingedsheep.sdk.scripting.AlternativePaymentChoice

/**
 * Result of applying alternative payment.
 *
 * @property reducedCost The mana cost after alternative payment reductions
 * @property newState The game state after applying the payment (e.g., exiled cards, tapped creatures)
 * @property events Events generated by the payment (exile, tap events)
 */
data class AlternativePaymentResult(
    val reducedCost: ManaCost,
    val newState: GameState,
    val events: List<GameEvent>
)

/**
 * Handles alternative payment methods like Delve and Convoke.
 *
 * **Delve**: Exile cards from your graveyard. Each card exiled this way pays for {1}.
 * **Convoke**: Tap untapped creatures you control. Each creature tapped this way pays for
 *             {1} or one mana of that creature's color.
 *
 * Alternative payments are applied AFTER cost reductions (like Ghalta/Affinity) but BEFORE
 * normal mana payment.
 */
class AlternativePaymentHandler {

    /**
     * Apply alternative payment choices to reduce the effective cost.
     *
     * @param state The current game state
     * @param cost The cost to pay (after cost reductions)
     * @param payment The player's alternative payment choices
     * @param playerId The player making the payment
     * @param cardDef The card being cast (to verify it has Delve/Convoke)
     * @return Result containing reduced cost, updated state, and generated events
     */
    fun apply(
        state: GameState,
        cost: ManaCost,
        payment: AlternativePaymentChoice,
        playerId: EntityId,
        cardDef: CardDefinition
    ): AlternativePaymentResult {
        var currentState = state
        var reducedCost = cost
        val events = mutableListOf<GameEvent>()

        // Handle Delve
        if (payment.delvedCards.isNotEmpty()) {
            val hasDelve = cardDef.keywords.contains(Keyword.DELVE)
            if (hasDelve) {
                val delveResult = applyDelve(currentState, reducedCost, payment.delvedCards, playerId)
                currentState = delveResult.newState
                reducedCost = delveResult.reducedCost
                events.addAll(delveResult.events)
            }
        }

        // Handle Convoke
        if (payment.convokedCreatures.isNotEmpty()) {
            val hasConvoke = cardDef.keywords.contains(Keyword.CONVOKE)
            if (hasConvoke) {
                val convokeResult = applyConvoke(currentState, reducedCost, payment.convokedCreatures, playerId)
                currentState = convokeResult.newState
                reducedCost = convokeResult.reducedCost
                events.addAll(convokeResult.events)
            }
        }

        return AlternativePaymentResult(reducedCost, currentState, events)
    }

    /**
     * Apply Delve payment by exiling cards from graveyard.
     */
    private fun applyDelve(
        state: GameState,
        cost: ManaCost,
        delvedCards: List<EntityId>,
        playerId: EntityId
    ): AlternativePaymentResult {
        var currentState = state
        val events = mutableListOf<GameEvent>()
        var genericReduction = 0

        val graveyardZone = ZoneKey(playerId, Zone.GRAVEYARD)
        val exileZone = ZoneKey(playerId, Zone.EXILE)

        for (cardId in delvedCards) {
            // Verify card is in player's graveyard
            if (cardId !in currentState.getZone(graveyardZone)) {
                continue // Skip invalid cards
            }

            val cardComponent = currentState.getEntity(cardId)?.get<CardComponent>()
                ?: continue

            // Move card from graveyard to exile
            currentState = currentState.removeFromZone(graveyardZone, cardId)
            currentState = currentState.addToZone(exileZone, cardId)

            events.add(
                ZoneChangeEvent(
                    entityId = cardId,
                    entityName = cardComponent.name,
                    fromZone = Zone.GRAVEYARD,
                    toZone = Zone.EXILE,
                    ownerId = playerId
                )
            )

            genericReduction++
        }

        val reducedCost = reduceGenericCost(cost, genericReduction)
        return AlternativePaymentResult(reducedCost, currentState, events)
    }

    /**
     * Apply Convoke payment by tapping creatures.
     */
    private fun applyConvoke(
        state: GameState,
        cost: ManaCost,
        convokedCreatures: Map<EntityId, com.wingedsheep.sdk.scripting.ConvokePayment>,
        playerId: EntityId
    ): AlternativePaymentResult {
        var currentState = state
        var reducedCost = cost
        val events = mutableListOf<GameEvent>()

        val battlefieldZone = ZoneKey(playerId, Zone.BATTLEFIELD)

        for ((creatureId, payment) in convokedCreatures) {
            // Verify creature is on player's battlefield and is untapped
            if (creatureId !in currentState.getZone(battlefieldZone)) {
                continue // Skip invalid creatures
            }

            val container = currentState.getEntity(creatureId) ?: continue
            val cardComponent = container.get<CardComponent>() ?: continue

            // Must be a creature
            if (!cardComponent.typeLine.isCreature) {
                continue
            }

            // Must be untapped
            if (container.has<TappedComponent>()) {
                continue
            }

            // Must be controlled by the player
            val controller = container.get<ControllerComponent>()?.playerId
            if (controller != playerId) {
                continue
            }

            // Tap the creature
            currentState = currentState.updateEntity(creatureId) { c ->
                c.with(TappedComponent)
            }

            events.add(TappedEvent(creatureId, cardComponent.name))

            // Apply the payment
            val paymentColor = payment.color
            if (paymentColor != null) {
                // Pay for colored mana
                reducedCost = reduceColoredCost(reducedCost, paymentColor)
            } else {
                // Pay for generic mana
                reducedCost = reduceGenericCost(reducedCost, 1)
            }
        }

        return AlternativePaymentResult(reducedCost, currentState, events)
    }

    /**
     * Reduce generic mana cost by specified amount.
     */
    private fun reduceGenericCost(cost: ManaCost, reduction: Int): ManaCost {
        if (reduction <= 0) return cost

        val coloredSymbols = cost.symbols.filter { it !is ManaSymbol.Generic }
        val genericAmount = cost.genericAmount
        val newGenericAmount = (genericAmount - reduction).coerceAtLeast(0)

        val newSymbols = if (newGenericAmount > 0) {
            listOf(ManaSymbol.Generic(newGenericAmount)) + coloredSymbols
        } else {
            coloredSymbols
        }

        return ManaCost(newSymbols)
    }

    /**
     * Reduce colored mana cost by one of the specified color.
     * If no matching colored symbol exists, does nothing.
     */
    private fun reduceColoredCost(cost: ManaCost, color: Color): ManaCost {
        val coloredSymbol = ManaSymbol.Colored(color)
        val mutableSymbols = cost.symbols.toMutableList()

        // Remove the first matching colored symbol
        val index = mutableSymbols.indexOfFirst { it == coloredSymbol }
        if (index >= 0) {
            mutableSymbols.removeAt(index)
        }

        return ManaCost(mutableSymbols)
    }

    companion object {
        /**
         * Check if a card definition supports alternative payment.
         */
        fun supportsAlternativePayment(cardDef: CardDefinition): Boolean {
            return cardDef.keywords.contains(Keyword.DELVE) ||
                    cardDef.keywords.contains(Keyword.CONVOKE)
        }
    }
}
